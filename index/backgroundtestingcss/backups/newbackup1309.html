<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cinematic Grid Tunnel with Pulsing Stars - Brighter</title>
    
    <style>
        /* --- CSS STYLES --- */
        
        /* Basic Reset and Setup */
        body {
            margin: 0;
            overflow-x: hidden;
            background-color: #000;
            font-family: 'Consolas', monospace; /* Futuristic font feel */
            color: #d0faff; /* Light blue/cyan text */
        }

        /* 1. Canvas Styling - The animated grid layer */
        #gridBackground {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2; /* Place it behind all other layers */
            /* Add a subtle initial shadow/blur for depth */
            filter: drop-shadow(0 0 5px rgba(0, 255, 255, 0.5));
        }

        /* 2. Dark Fade Overlay (Retained and Enhanced) */
        .fade-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
            
            /* Enhanced gradient to darken the edges and the far distance */
            background: radial-gradient(
                circle at center,
                rgba(0, 0, 0, 0) 50%,
                rgba(0, 0, 0, 0.2) 75%,
                rgba(0, 0, 0, 0.4) 100%
            ),
            linear-gradient(
                to bottom,
                rgba(0, 0, 0, 0.8) 0%, /* Darkens the top (sky) slightly */
                rgba(0, 0, 0, 0) 40%,
                rgba(0, 0, 0, 0.7) 90%,
                rgba(0, 0, 0, 1) 100%
            );
        }

        /* 3. Content Layer Styling */
        .content {
            position: relative;
            z-index: 1;
            min-height: 200vh;
            padding: 50px;
            text-align: center;
            /* Add a subtle text glow */
            text-shadow: 0 0 5px #00aaff;
        }

        h1 {
            color: #00ffff;
            font-size: 4em;
            letter-spacing: 5px;
        }
    </style>
</head>
<body>

    <canvas id="gridBackground"></canvas>
    <div class="fade-overlay"></div>
    <div class="content">
        <h1>FUTURE GRID ENGAGED</h1>
        <p>This is the combined grid and pulsing stars background.</p>
        <p>Try moving your mouse to see the grid subtly tilt and react!</p>
        <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
        <p>End of scrollable content. The background is fixed.</p>
    </div>

    <script>
        // --- JAVASCRIPT ANIMATION LOGIC ---

        const canvas = document.getElementById('gridBackground');
        const ctx = canvas.getContext('2d');

        // --- Configuration ---
        const DENSITY = 30;     // Total number of vertical lines
        const HORIZONTAL_LINES = 150; // Total number of horizontal lines
        const F_SPEED = 0.05;   // Base speed of the forward motion
        const PERSPECTIVE_SCALE = 150; // Perspective depth factor
        
        let width, height;
        let lines = [];
        let mouseX = 0, mouseY = 0; // Mouse position variables

        // --- PULSING STAR FIELD DATA ---
        const STAR_COUNT = 300;
        let stars = [];
        const starSpeed = 0.05; // Base movement speed for floating stars

        // --- Star Class (Modified for brighter/larger stars) ---
        class Star {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                // Randomly set size to 1px or 2px
                this.size = Math.random() > 0.8 ? 2 : 1; 
                this.pulseOffset = Math.random() * Math.PI * 2; // Starting phase for pulsing
                // Increased base opacity for brighter stars (0.7 to 1.0)
                this.opacity = Math.random() * 0.3 + 0.7; 
                this.speedX = (Math.random() - 0.5) * starSpeed;
                this.speedY = (Math.random() - 0.5) * starSpeed;
            }

            update() {
                // Random movement
                this.x += this.speedX;
                this.y += this.speedY;

                // Loop stars when they go off-screen
                if (this.x < 0) this.x = width;
                if (this.x > width) this.x = 0;
                if (this.y < 0) this.y = height;
                if (this.y > height) this.y = 0;

                // Pulsing effect: uses a sine wave for smooth, random pulsing
                // Pulsing factor adjusted to keep the minimum brightness higher
                const pulse = Math.sin(Date.now() / 500 + this.pulseOffset); // Time-based pulsing
                this.currentOpacity = this.opacity * (0.7 + 0.3 * pulse); 
            }

            draw() {
                // Use a subtle white glow for a brighter look
                ctx.fillStyle = `rgba(255, 255, 255, ${this.currentOpacity})`;
                ctx.fillRect(this.x, this.y, this.size, this.size);
            }
        }
        
        // Initialize Star Field
        function initStars() {
            stars = []; // Clear existing stars on resize
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push(new Star());
            }
        }

        // Handle resizing and initial setup
        function resizeCanvas() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            // Re-initialize stars with new dimensions
            initStars(); 

            // Initialize vertical lines
            lines = [];
            for (let i = 0; i < DENSITY; i++) {
                lines.push({
                    z: Math.random() * 200, // Random Z position
                    // X offset calculation ensures lines are symmetrical around the center
                    xOffset: (i - DENSITY / 2) * (width / DENSITY / 2.5) 
                });
            }
        }

        // Handle Mouse Movement (for grid tilt)
        window.addEventListener('mousemove', (e) => {
            // Normalize mouse coordinates to a -0.5 to 0.5 range relative to the center
            mouseX = (e.clientX / width - 0.5) * 0.5;
            mouseY = (e.clientY / height - 0.5) * 0.5;
        });

        // --- DRAW FUNCTIONS ---

        function drawStars() {
            // Draw the pulsing, randomly moving stars
            stars.forEach(star => {
                star.update();
                star.draw();
            });
        }

        function drawGrid(time) {
            // Clear the canvas each frame
            ctx.clearRect(0, 0, width, height);

            // Dynamic Horizon (Tilts slightly with mouseY, fixed at center)
            const horizonY = height * 0.45; 
            const centerX = width / 2;

            // Color Pulse: Subtle change in the line color over time
            const colorPulse = 0.5 + Math.sin(time * 0.0005) * 0.5;
            const hue = 180 + colorPulse * 60; // Shift from cyan (180) toward green (240)
            const saturation = 100;
            const lightness = 60;

            // --- Draw Horizontal Lines (Depth) ---
            for (let d = 0; d < HORIZONTAL_LINES; d += 1) {
                // Z value, animated by time to look like it's passing
                let z = d * 4 + (time * F_SPEED) % 4; 

                // Perspective calculation: farther objects (high Z) are closer to horizonY
                let y = horizonY + (height * 10) / z;

                if (y > height) continue;
                
                // Fade the lines out as they go into the distance
                let alpha = 1 - (z / (HORIZONTAL_LINES * 4)); 
                
                // Use HSL for dynamic color, fading to transparency
                ctx.strokeStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha * 0.25})`;
                ctx.lineWidth = Math.max(0.5, 3 / z * PERSPECTIVE_SCALE * 0.05); // Line thickness based on Z

                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // --- Draw Vertical Lines (Tunnel Walls) ---
            for (let i = 0; i < DENSITY; i++) {
                const line = lines[i];
                
                // Move the line closer
                line.z -= F_SPEED * 0.5; 
                
                // Reset line to far distance
                if (line.z < 1) {
                    line.z = 200; 
                }

                // Calculate X position using perspective + Mouse Tilt
                // MouseX tilts the entire plane horizontally
                let perspectiveX = (line.xOffset) / line.z * PERSPECTIVE_SCALE;
                let x = centerX + perspectiveX + (mouseX * width * (1 / line.z * 10)); 
                
                // Calculate Y positions
                let yTop = 0; // Start at the top of the canvas
                let yBottom = horizonY + (height * 10) / line.z; // End at the floor perspective

                // Fade lines as they get farther away (higher Z)
                let alpha = 1 - (line.z / 200);
                
                ctx.strokeStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha * 0.5})`;
                ctx.lineWidth = Math.max(0.5, 5 / line.z * PERSPECTIVE_SCALE * 0.05);

                // Draw the full vertical line segment
                ctx.beginPath();
                ctx.moveTo(x, yTop);
                ctx.lineTo(x, yBottom);
                ctx.stroke();
            }
        }

        // The main animation loop
        function animate(timestamp) {
            
            // 1. Draw the grid and clear the frame
            drawGrid(timestamp);
            
            // 2. Draw the non-perspective, pulsing stars on top of the grid
            drawStars();

            // Request the next frame
            requestAnimationFrame(animate);
        }

        // Start the whole process
        window.addEventListener('load', () => {
            resizeCanvas(); 
            animate(0); // Pass initial timestamp
        });
        window.addEventListener('resize', resizeCanvas);

    </script>
</body>
</html>